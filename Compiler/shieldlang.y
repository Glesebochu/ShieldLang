/* Definitions Section */
%{
#include <iostream> // Include iostream for input/output operations
#include <cstdlib>  // Include cstdlib for general-purpose functions (e.g., atoi, atof)
#include <cstdio>   // Include cstdio for file input/output functions
#include "ASTNode.h" //Include the AstNode.h
#include "SymbolTable.h" // Include the symbol table
#include "ASTTraversal.h"
using namespace std;

// Declare stuff from Flex that Bison needs to know about
void yyerror(const char *s); // Function for error handling
extern int yylex();          // Function generated by Flex to tokenize input
extern int linenum;          // Variable to keep track of line numbers
extern FILE *yyin;           // Variable to point to the input file
#define ASTNodePtr ASTNode*

// Declare root globally
ASTNodePtr root = nullptr;

// Declare helper functions
ASTNodePtr createAssignmentNode(const std::string &identifier, ASTNodePtr right);
ASTNodePtr createOperatorNode(const std::string &op, ASTNodePtr left, ASTNodePtr right);
ASTNodePtr createSequenceNode(ASTNodePtr first, ASTNodePtr second);
NodeType convertDataTypeToNodeType(DataType dataType);
%}

// Define YYSTYPE to include different types
%union {
    int ival;
    float fval;
    char *sval;
    ASTNode* node;
    DataType type;  // Add type to the union to hold data types
}


/* Declare tokens to be used by Bison */
%token <ival> INTEGER 
%token <fval> FLOAT 
%token <sval> STRING 
%token <sval> IDENTIFIER
%token TEST

%type <node> expression operator operand
%type <type> data_type

// Keywords
%token KEHONE
%token LELAKEHONE
%token KALHONE
%token ESKEHONE
%token DELTA
%token MELS
%token MINEM
%token AQUM
%token QETEL
%token SIRA
%token YEMIQEYER
%token YEMAYQEYER
%token EWNET
%token HASET

// Data types
%token NOVEM
%token DECEM
%token DUO
%token UNUM
%token VERBUM

// Arithmetic Operators
%token ASSIGN
%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE

// Comparison Operators
%token EQ
%token NE
%token LT 
%token GT 
%token LE 
%token GE 

// Logical Operators
%token AND 
%token OR 
%token NOT 


// Punctuation
%token SEMICOLON
%token COMMA
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE

/* Declare precedence and associativity */
%left OR
%left AND
%right NOT
%nonassoc EQ NE LT GT LE GE
%left PLUS MINUS
%left MULTIPLY DIVIDE
%debug


/* Rules Section */
%%
/* The input rule matches the entire input. It consists of zero or more statements. */
input:
      /* empty */
    | input statement   // Input can be empty or can contain multiple statements
    ;



/* Define the statement rule for different types of statements. */
statement:
      expression SEMICOLON 
    | stmt 
    | INTEGER { 
          cout << "Integer value: " << $1 << endl; 
      }
    | FLOAT { 
          cout << "Float value: " << $1 << endl; 
      }
    | TEST { 
          cout << "Test command detected." << endl; 
      }
    | STRING { 
          cout << "String detected: " << $1 << endl; 
      }
    | IDENTIFIER {
        cout << "Identifier detected: " << $1 << endl;
      }
    ;

expression:
    IDENTIFIER ASSIGN operand operator operand {
        if (isDeclared($1)) {
            SymbolInfo symbol = getFromSymbolTable($1);
            if (convertDataTypeToNodeType(symbol.type) == $3->type && $3->type == $5->type) {
                $$ = createAssignmentNode($1, createOperatorNode($4->value, $3, $5));
                root = (root == nullptr) ? $$ : createSequenceNode(root, $$);
            } else {
                std::cerr << "Error: Type mismatch in operation or assignment to " << $1 << std::endl;
            }
        } else {
            std::cerr << "Error: Variable " << $1 << " is not declared." << std::endl;
        }
    }
    | IDENTIFIER ASSIGN operand {
        if (isDeclared($1)) {
            SymbolInfo symbol = getFromSymbolTable($1);
            if (convertDataTypeToNodeType(symbol.type) == $3->type) {
                $$ = createAssignmentNode($1, $3);
                root = (root == nullptr) ? $$ : createSequenceNode(root, $$);
            } else {
                std::cerr << "Error: Type mismatch in assignment to " << $1 << std::endl;
            }
        } else {
            std::cerr << "Error: Variable " << $1 << " is not declared." << std::endl;
        }
    }
    | data_type IDENTIFIER ASSIGN operand operator operand {
        if (!isDeclared($2)) {
            addToSymbolTable($2, $1);  // Add identifier with its type
            if (convertDataTypeToNodeType($1) == $4->type && $4->type == $6->type) {
                $$ = createAssignmentNode($2, createOperatorNode($5->value, $4, $6));
                root = (root == nullptr) ? $$ : createSequenceNode(root, $$);
            } else {
                std::cerr << "Error: Type mismatch in operation or assignment to " << $2 << std::endl;
            }
        } else {
            std::cerr << "Error: Variable " << $2 << " already declared." << std::endl;
        }
    }
    | data_type IDENTIFIER ASSIGN operand {
        if (!isDeclared($2)) {
            addToSymbolTable($2, $1);  // Add identifier with its type
            if (convertDataTypeToNodeType($1) == $4->type) {
                $$ = createAssignmentNode($2, $4);
                root = (root == nullptr) ? $$ : createSequenceNode(root, $$);
            } else {
                std::cerr << "Error: Type mismatch in assignment to " << $2 << std::endl;
            }
        } else {
            std::cerr << "Error: Variable " << $2 << " already declared." << std::endl;
        }
    }
    ;


operand:
      INTEGER {
          $$ = new ASTNode(NODE_NUMBER, std::to_string($1));
      }
    | FLOAT {
          $$ = new ASTNode(NODE_NUMBER, std::to_string($1));
      }
    | IDENTIFIER {
              $$ = new ASTNode(NODE_IDENTIFIER, $1);
      }
    | STRING {
          $$ = new ASTNode(NODE_STRING, $1);  // Assuming strings are treated like identifiers
      }
    ;



num:
      INTEGER
      | FLOAT
    ;

/* Define operators */
operator:
    PLUS {
        $$ = new ASTNode(NODE_OPERATOR, "+");
    }
  | MINUS {
        $$ = new ASTNode(NODE_OPERATOR, "-");
    }
  | MULTIPLY {
        $$ = new ASTNode(NODE_OPERATOR, "*");
    }
  | DIVIDE {
        $$ = new ASTNode(NODE_OPERATOR, "/");
    }
  ;

/* Define what a statement should look like */
stmt:
      if_stmt{
        cout << "If statement executed successfully" <<endl;
      }
    | if_stmt else_stmt{
        cout <<"If else statement evaluated successfully"<<endl;
      }
    | if_stmt elif else_stmt{

        cout <<"If elif, else statement evaluated successfully"<<endl;
      }
    | loop_stmt{
        cout << "Loop statement executed successfully" <<endl;
      }
    | flow_control

    | function{
        cout << "Function evaluated" << endl;
    }
    ;
//Define what a function should look like
function:
      SIRA return_type IDENTIFIER LPAREN params RPAREN function_definition
    ;

//Define what parameters should look like
params:
      data_type IDENTIFIER COMMA params
      | data_type IDENTIFIER
    ;

//Define what a return type is
return_type:
      NOVEM
      | DECEM
      | DUO
      | UNUM
      | VERBUM
      | MINEM
    ;
//Define what a data type is
data_type:
      NOVEM   { $$ = TYPE_INTEGER; }
    | DECEM   { $$ = TYPE_FLOAT; }
    | DUO     { $$ = TYPE_BOOLEAN; }
    | UNUM    { $$ = TYPE_BOOLEAN; }
    | VERBUM  { $$ = TYPE_STRING; }
    ;

/* Define what an if statement should look like */
if_stmt:
      KEHONE LPAREN conditions RPAREN definition
    ;
else_stmt:
      KALHONE definition
    ;
elif:
      elif_stmt
    | elif_stmt elif
  ;

elif_stmt:
      LELAKEHONE LPAREN conditions RPAREN definition

/* Define what a loop should look like */
loop_stmt:
      while_loop
    | for_loop
    ;

/* Define what a while loop should look like */
while_loop:
      ESKEHONE LPAREN conditions RPAREN definition
    ;

/* Define what a for loop should look like */
for_loop:
      DELTA LPAREN for_loop_declaration RPAREN definition
    ;
flow_control:
      AQUM SEMICOLON
      | QETEL SEMICOLON
    ;

for_loop_declaration:
      for_loop_initialization SEMICOLON conditions SEMICOLON increment_decrement_list
    ;
for_loop_initialization:
      data_type IDENTIFIER ASSIGN num
      | data_type IDENTIFIER ASSIGN num COMMA for_loop_initialization
    ;
increment_decrement_list:
      increment_decrement
      | increment_decrement_list COMMA increment_decrement
    ;
increment_decrement:
      IDENTIFIER PLUS PLUS
      | IDENTIFIER MINUS MINUS
    ; 
/* Top-level condition rule */
conditions:
      condition_expression
    ;

/* General condition expression */
condition_expression:
      or_expression
      | LPAREN condition_expression RPAREN
    ;

/* Handle OR operations */
or_expression:
      or_expression OR and_expression
      | and_expression
    ;

/* Handle AND operations */
and_expression:
      and_expression AND not_expression
      | not_expression
    ;

/* Handle NOT operations */
not_expression:
      NOT not_expression
      | comparison
    ;

/* Handle comparisons */
comparison:
      operand comparison_operators operand
      | boolean
      | IDENTIFIER
    ;

  
/* Define what a definition should look like for a loop and an if statement */
definition:
      LBRACE body RBRACE
    ;
/* Define what a definition should look like for a function this is because functions can have
   a return statement.
 */
function_definition:
      LBRACE body RBRACE
      | LBRACE body return_statement RBRACE
    ;
/* Define what a return statement looks like for a function*/
return_statement:
      MELS IDENTIFIER SEMICOLON
      | MELS STRING SEMICOLON
      | MELS FLOAT SEMICOLON
      | MELS INTEGER SEMICOLON
      | MELS boolean SEMICOLON

      ;

boolean:
      EWNET
      | HASET
    ;
/* Define what a body should look like for if statements and loops */
body:
      statement body
    | /* empty */
    ;

/* Define comparison operators */
comparison_operators:
      EQ
      | NE
      | LT 
      | GT 
      | LE 
      | GE
    ;

%%

/* User Code Section */

/* Function for handling errors, called by Bison when a syntax error is encountered */
void yyerror(const char *s)
{
    cerr << "Error: " << s << " at line " << linenum << endl;
}
/* User Code Section */
ASTNodePtr createAssignmentNode(const std::string &identifier, ASTNodePtr right) {
    /* std::cout << "Creating assignment node: " << identifier << " = " << right->value << std::endl; */
    ASTNodePtr assignNode = new ASTNode(NODE_ASSIGNMENT, "=");
    assignNode->left = new ASTNode(NODE_IDENTIFIER, identifier);
    assignNode->right = right;
    return assignNode;
}

ASTNodePtr createOperatorNode(const std::string &op, ASTNodePtr left, ASTNodePtr right) {
    /* std::cout << "Creating operator node: " << left->value << " " << op << " " << right->value << std::endl; */
    ASTNodePtr opNode = new ASTNode(NODE_OPERATOR, op);
    opNode->left = left;
    opNode->right = right;
    return opNode;
}
ASTNodePtr createSequenceNode(ASTNodePtr first, ASTNodePtr second) {
    ASTNodePtr sequenceNode = new ASTNode(NODE_SEQUENCE, ";");
    sequenceNode->left = first;
    sequenceNode->right = second;
    return sequenceNode;
}


void printAST(ASTNode* node, int indent = 0) {
    if (!node) return;

    for (int i = 0; i < indent; ++i) std::cout << "  ";
    std::cout << "Node Type: " << node->type << ", Value: " << node->value << std::endl;

    printAST(node->left, indent + 1);
    printAST(node->right, indent + 1);
}

NodeType convertDataTypeToNodeType(DataType dataType) {
    switch (dataType) {
        case TYPE_INTEGER: return NODE_NUMBER;
        case TYPE_FLOAT: return NODE_NUMBER;
        case TYPE_STRING: return NODE_STRING;
        // Add other conversions as needed
        default: return NODE_UNKNOWN; // Define NODE_UNKNOWN if not already defined
    }
}




/* Main function */
int main(int argc, char **argv)
{
    yydebug = 0;  // Enable debugging when it is 1
    // If a filename is provided as a command-line argument, open the file
    if (argc > 1)
    {
        FILE *file = fopen(argv[1], "r");
        if (!file)
        {
            // If the file cannot be opened, print an error message and exit
            cerr << "Could not open file: " << argv[1] << endl;
            return 1;
        }
        // Set yyin to the file pointer so Flex reads from the file
        yyin = file;
    }
    else
    {
        // If no file is provided, read from standard input (e.g., keyboard)
        yyin = stdin;
    }

    // Call yyparse to start parsing the input
    int result = yyparse();
    if(result == 0 && root!=nullptr) {
        std::cout << "AST Root Node Type: " << root->type << std::endl;
        printAST(root);
        generateTASMFile(root,"TestProgramShieldlang");
        std::cout << "File parsed and TASM generated successfully." << std::endl;
    } else {
        std::cerr << "Parsing failed or root is null." << std::endl;
    }

    return 0;
}
