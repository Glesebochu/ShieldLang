/* Definitions Section */
%{
#include <iostream> // Include iostream for input/output operations
#include <cstdlib>  // Include cstdlib for general-purpose functions (e.g., atoi, atof)
#include <cstdio>   // Include cstdio for file input/output functions
#include "ASTNode.h" //Include the AstNode.h
#include "SymbolTable.h" // Include the symbol table
#include "ASTTraversal.h"
using namespace std;

// Declare stuff from Flex that Bison needs to know about
void yyerror(const char *s); // Function for error handling
extern int yylex();          // Function generated by Flex to tokenize input
extern int linenum;          // Variable to keep track of line numbers
extern FILE *yyin;           // Variable to point to the input file
#define ASTNodePtr ASTNode*

// Declare root globally
ASTNodePtr root = nullptr;

// Declare helper functions
ASTNodePtr createAssignmentNode(const std::string &identifier, ASTNodePtr right);
ASTNodePtr createOperatorNode(const std::string &op, ASTNodePtr left, ASTNodePtr right);
ASTNodePtr createSequenceNode(ASTNodePtr first, ASTNodePtr second);
%}

// Define YYSTYPE to include different types
%union {
    int ival;
    float fval;
    char *sval;
    ASTNode* node;  // Use ASTNode* directly
}

/* Declare tokens to be used by Bison */
%token <ival> INTEGER 
%token <fval> FLOAT 
%token <sval> STRING 
%token <sval> IDENTIFIER
%token TEST

%type <node> expression operator num

// Keywords
%token KEHONE
%token LELAKEHONE
%token KALHONE
%token ESKEHONE
%token DELTA
%token MELS
%token MINEM
%token AQUM
%token QETEL
%token SIRA
%token YEMIQEYER
%token YEMAYQEYER
%token EWNET
%token HASET

// Data types
%token NOVEM
%token DECEM
%token DUO
%token UNUM
%token VERBUM

// Arithmetic Operators
%token ASSIGN
%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE

// Comparison Operators
%token EQ
%token NE
%token LT 
%token GT 
%token LE 
%token GE 

// Logical Operators
%token AND 
%token OR 
%token NOT 


// Punctuation
%token SEMICOLON
%token COMMA
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE

/* Declare precedence and associativity */
%left OR
%left AND
%right NOT
%nonassoc EQ NE LT GT LE GE
%left PLUS MINUS
%left MULTIPLY DIVIDE
%debug


/* Rules Section */
%%
/* The input rule matches the entire input. It consists of zero or more statements. */
input:
      /* empty */
    | input statement   // Input can be empty or can contain multiple statements
    ;



/* Define the statement rule for different types of statements. */
statement:
      expression SEMICOLON 
    | stmt 
    | INTEGER { 
          cout << "Integer value: " << $1 << endl; 
      }
    | FLOAT { 
          cout << "Float value: " << $1 << endl; 
      }
    | TEST { 
          cout << "Test command detected." << endl; 
      }
    | STRING { 
          cout << "String detected: " << $1 << endl; 
      }
    | IDENTIFIER {
        cout << "Identifier detected: " << $1 << endl;
      }
    ;

expression:
      IDENTIFIER ASSIGN num operator num {
          std::cout << "Assigning root with expression: " << $1 << " = " << $3 << " " << $4->value << " " << $5 << std::endl;
          $$ = createAssignmentNode($1, createOperatorNode($4->value, $3, $5));
          root = $$;
      }
    | IDENTIFIER ASSIGN num {
          ASTNodePtr newExpressionNode = createAssignmentNode($1, $3);
          if (root == nullptr) {
              root = newExpressionNode;
          } else {
              root = createSequenceNode(root, newExpressionNode);
          }
          cout<<"The value of root is: "<<root->value<<endl;
          cout<<"!!On the left or root is: "<<root->left->value<<endl;
          cout<<"!!On the right or root is: "<<root->right->value<<endl;
          if(root->left->left!=nullptr&&root->left->right!=nullptr){
            cout<<"!!On the left left of root is: "<<root->left->left->value<<endl;
            cout<<"!!On the left right of root is: "<<root->left->right->value<<endl;
            cout<<"!!On the right left of root is: "<<root->right->left->value<<endl;
            cout<<"!!On the right right of root is: "<<root->right->right->value<<endl;

          }


      }
    | IDENTIFIER ASSIGN IDENTIFIER operator num {
          $$ = createAssignmentNode($1, createOperatorNode($4->value, new ASTNode(NODE_IDENTIFIER, $3), $5));
          root = $$;
      }
    | IDENTIFIER ASSIGN num operator IDENTIFIER {
          $$ = createAssignmentNode($1, createOperatorNode($4->value, $3, new ASTNode(NODE_IDENTIFIER, $5)));
          root = $$;
      }
    | IDENTIFIER ASSIGN IDENTIFIER operator IDENTIFIER {
          $$ = createAssignmentNode($1, createOperatorNode($4->value, new ASTNode(NODE_IDENTIFIER, $3), new ASTNode(NODE_IDENTIFIER, $5)));
          root = $$;
      }
    | IDENTIFIER ASSIGN IDENTIFIER {
          $$ = createAssignmentNode($1, new ASTNode(NODE_IDENTIFIER, $3));
          root = $$;
      }
    | IDENTIFIER ASSIGN STRING {
          $$ = createAssignmentNode($1, new ASTNode(NODE_IDENTIFIER, $3));
          root = $$;
      }
    | data_type IDENTIFIER ASSIGN num operator num {
          $$ = createAssignmentNode($2, createOperatorNode($5->value, $4, $6));
          root = $$;
      }
    | data_type IDENTIFIER ASSIGN num {
          $$ = createAssignmentNode($2, $4);
          root = $$;
      }
    | data_type IDENTIFIER ASSIGN IDENTIFIER operator num {
          $$ = createAssignmentNode($2, createOperatorNode($5->value, new ASTNode(NODE_IDENTIFIER, $4), $6));
          root = $$;
      }
    | data_type IDENTIFIER ASSIGN num operator IDENTIFIER {
          $$ = createAssignmentNode($2, createOperatorNode($5->value, $4, new ASTNode(NODE_IDENTIFIER, $6)));
          root = $$;
      }
    | data_type IDENTIFIER ASSIGN IDENTIFIER operator IDENTIFIER {
          $$ = createAssignmentNode($2, createOperatorNode($5->value, new ASTNode(NODE_IDENTIFIER, $4), new ASTNode(NODE_IDENTIFIER, $6)));
          root = $$;
      }
    | data_type IDENTIFIER ASSIGN IDENTIFIER {
          $$ = createAssignmentNode($2, new ASTNode(NODE_IDENTIFIER, $4));
          root = $$;
      }
    | data_type IDENTIFIER ASSIGN STRING {
          $$ = createAssignmentNode($2, new ASTNode(NODE_IDENTIFIER, $4));
          root = $$;
      }
    ;



num:
      INTEGER {
          $$ = new ASTNode(NODE_NUMBER, std::to_string($1));
          cout<<"The Integer is "<<$$->value<<endl;
      }
    | FLOAT {
          $$ = new ASTNode(NODE_NUMBER, std::to_string($1));
      }
    ;


/* Define operators */
operator:
      PLUS
    | MINUS
    | MULTIPLY
    | DIVIDE
    ;

/* Define what a statement should look like */
stmt:
      if_stmt{
        cout << "If statement executed successfully" <<endl;
      }
    | if_stmt else_stmt{
        cout <<"If else statement evaluated successfully"<<endl;
      }
    | if_stmt elif else_stmt{

        cout <<"If elif, else statement evaluated successfully"<<endl;
      }
    | loop_stmt{
        cout << "Loop statement executed successfully" <<endl;
      }
    | flow_control

    | function{
        cout << "Function evaluated" << endl;
    }
    ;
//Define what a function should look like
function:
      SIRA return_type IDENTIFIER LPAREN params RPAREN function_definition
    ;

//Define what parameters should look like
params:
      data_type IDENTIFIER COMMA params
      | data_type IDENTIFIER
    ;

//Define what a return type is
return_type:
      NOVEM
      | DECEM
      | DUO
      | UNUM
      | VERBUM
      | MINEM
    ;
//Define what a data type is
data_type:
      NOVEM
      | DECEM
      | DUO
      | UNUM
      | VERBUM
    ;
/* Define what an if statement should look like */
if_stmt:
      KEHONE LPAREN conditions RPAREN definition
    ;
else_stmt:
      KALHONE definition
    ;
elif:
      elif_stmt
    | elif_stmt elif
  ;

elif_stmt:
      LELAKEHONE LPAREN conditions RPAREN definition

/* Define what a loop should look like */
loop_stmt:
      while_loop
    | for_loop
    ;

/* Define what a while loop should look like */
while_loop:
      ESKEHONE LPAREN conditions RPAREN definition
    ;

/* Define what a for loop should look like */
for_loop:
      DELTA LPAREN for_loop_declaration RPAREN definition
    ;
flow_control:
      AQUM SEMICOLON
      | QETEL SEMICOLON
    ;

for_loop_declaration:
      for_loop_initialization SEMICOLON conditions SEMICOLON increment_decrement_list
    ;
for_loop_initialization:
      data_type IDENTIFIER ASSIGN num
      | data_type IDENTIFIER ASSIGN num COMMA for_loop_initialization
    ;
increment_decrement_list:
      increment_decrement
      | increment_decrement_list COMMA increment_decrement
    ;
increment_decrement:
      IDENTIFIER PLUS PLUS
      | IDENTIFIER MINUS MINUS
    ; 
/* Top-level condition rule */
conditions:
      condition_expression
    ;

/* General condition expression */
condition_expression:
      or_expression
      | LPAREN condition_expression RPAREN
    ;

/* Handle OR operations */
or_expression:
      or_expression OR and_expression
      | and_expression
    ;

/* Handle AND operations */
and_expression:
      and_expression AND not_expression
      | not_expression
    ;

/* Handle NOT operations */
not_expression:
      NOT not_expression
      | comparison
    ;

/* Handle comparisons */
comparison:
      operand comparison_operators operand
      | boolean
      | IDENTIFIER
    ;

  
/* Define what a definition should look like for a loop and an if statement */
definition:
      LBRACE body RBRACE
    ;
/* Define what a definition should look like for a function this is because functions can have
   a return statement.
 */
function_definition:
      LBRACE body RBRACE
      | LBRACE body return_statement RBRACE
    ;
/* Define what a return statement looks like for a function*/
return_statement:
      MELS IDENTIFIER SEMICOLON
      | MELS STRING SEMICOLON
      | MELS FLOAT SEMICOLON
      | MELS INTEGER SEMICOLON
      | MELS boolean SEMICOLON

      ;

boolean:
      EWNET
      | HASET
    ;
/* Define what a body should look like for if statements and loops */
body:
      statement body
    | /* empty */
    ;

/* Define what an operand can be */
operand:
      INTEGER
    | FLOAT
    | IDENTIFIER
    | STRING
    | boolean
    ;

/* Define comparison operators */
comparison_operators:
      EQ
      | NE
      | LT 
      | GT 
      | LE 
      | GE
    ;

%%

/* User Code Section */

/* Function for handling errors, called by Bison when a syntax error is encountered */
void yyerror(const char *s)
{
    cerr << "Error: " << s << " at line " << linenum << endl;
}
/* User Code Section */
ASTNodePtr createAssignmentNode(const std::string &identifier, ASTNodePtr right) {
    std::cout << "Creating assignment node: " << identifier << " = " << right->value << std::endl;
    ASTNodePtr assignNode = new ASTNode(NODE_ASSIGNMENT, "=");
    assignNode->left = new ASTNode(NODE_IDENTIFIER, identifier);
    assignNode->right = right;
    return assignNode;
}

ASTNodePtr createOperatorNode(const std::string &op, ASTNodePtr left, ASTNodePtr right) {
    std::cout << "Creating operator node: " << left->value << " " << op << " " << right->value << std::endl;
    ASTNodePtr opNode = new ASTNode(NODE_OPERATOR, op);
    opNode->left = left;
    opNode->right = right;
    return opNode;
}
ASTNodePtr createSequenceNode(ASTNodePtr first, ASTNodePtr second) {
    ASTNodePtr sequenceNode = new ASTNode(NODE_SEQUENCE, ";");
    sequenceNode->left = first;
    sequenceNode->right = second;
    return sequenceNode;
}


void printAST(ASTNode* node, int indent = 0) {
    if (!node) return;

    for (int i = 0; i < indent; ++i) std::cout << "  ";
    std::cout << "Node Type: " << node->type << ", Value: " << node->value << std::endl;

    printAST(node->left, indent + 1);
    printAST(node->right, indent + 1);
}



/* Main function */
int main(int argc, char **argv)
{
    yydebug = 1;  // Enable debugging
    // If a filename is provided as a command-line argument, open the file
    if (argc > 1)
    {
        FILE *file = fopen(argv[1], "r");
        if (!file)
        {
            // If the file cannot be opened, print an error message and exit
            cerr << "Could not open file: " << argv[1] << endl;
            return 1;
        }
        // Set yyin to the file pointer so Flex reads from the file
        yyin = file;
    }
    else
    {
        // If no file is provided, read from standard input (e.g., keyboard)
        yyin = stdin;
    }
    ASTNode* root = nullptr;  // This should be the root of the AST

    // Call yyparse to start parsing the input
    int result = yyparse();
    if(result == 0 && root!=nullptr) {
        std::cout << "AST Root Node Type: " << root->type << std::endl;
        printAST(root);
        generateTASM(root);
        std::cout << "File parsed and TASM generated successfully." << std::endl;
    } else {
        std::cerr << "Parsing failed or root is null." << std::endl;
    }

    return 0;
}
