/* Definitions Section */
%{
#include <iostream> // Include iostream for input/output operations
#include <cstdlib>  // Include cstdlib for general-purpose functions (e.g., atoi, atof)
#include <cstdio>   // Include cstdio for file input/output functions
#include "ASTNode.h" //Include the AstNode.h
#include "SymbolTable.h" // Include the symbol table
#include "ASTTraversal.h"
using namespace std;

// Declare stuff from Flex that Bison needs to know about
void yyerror(const char *s); // Function for error handling
extern int yylex();          // Function generated by Flex to tokenize input
extern int linenum;          // Variable to keep track of line numbers
extern FILE *yyin;           // Variable to point to the input file
#define ASTNodePtr ASTNode*

// Declare root globally
ASTNodePtr root = nullptr;

// Declare helper functions
ASTNodePtr createAssignmentNode(const std::string &identifier, ASTNodePtr right);
ASTNodePtr createOperatorNode(const std::string &op, ASTNodePtr left, ASTNodePtr right);
ASTNodePtr createSequenceNode(ASTNodePtr first, ASTNodePtr second);
NodeType convertDataTypeToNodeType(DataType dataType);
%}

// Define YYSTYPE to include different types
%union {
    int ival;
    float fval;
    char *sval;
    ASTNode* node;
    DataType type;  // Add type to the union to hold data types
}


/* Declare tokens to be used by Bison */
%token <ival> INTEGER 
%token <fval> FLOAT 
%token <sval> STRING 
%token <sval> IDENTIFIER
%token TEST

%type <node> expression operator operand
%type <type> data_type

// Keywords
%token KEHONE
%token LELAKEHONE
%token KALHONE
%token ESKEHONE
%token DELTA
%token MELS
%token MINEM
%token AQUM
%token QETEL
%token SIRA
%token YEMIQEYER
%token YEMAYQEYER
%token EWNET
%token HASET

// Data types
%token NOVEM
%token DECEM
%token DUO
%token UNUM
%token VERBUM

// Arithmetic Operators
%token ASSIGN
%token PLUS
%token MINUS
%token MULTIPLY
%token DIVIDE

// Comparison Operators
%token EQ
%token NE
%token LT 
%token GT 
%token LE 
%token GE 

// Logical Operators
%token AND 
%token OR 
%token NOT 


// Punctuation
%token SEMICOLON
%token COMMA
%token LPAREN
%token RPAREN
%token LBRACE
%token RBRACE

/* Declare precedence and associativity */
%left OR
%left AND
%right NOT
%nonassoc EQ NE LT GT LE GE
%left PLUS MINUS
%left MULTIPLY DIVIDE
%debug


/* Rules Section */
%%
/* The input rule matches the entire input. It consists of zero or more statements. */
input:
      /* empty */
    | input statement   // Input can be empty or can contain multiple statements
    ;



/* Define the statement rule for different types of statements. */
statement:
    expression SEMICOLON 

    // Error recovery for invalid statements
    | error SEMICOLON {
        std::cerr << "Error: Invalid statement at line " << linenum << ". Skipping to next statement." << std::endl;
        yyerrok; // Recover from the error and continue parsing
    }
    
    | stmt 
    | INTEGER { 
          cout << "Integer value: " << $1 << endl; 
      }
    | FLOAT { 
          cout << "Float value: " << $1 << endl; 
      }
    | TEST { 
          cout << "Test command detected." << endl; 
      }
    | STRING { 
          cout << "String detected: " << $1 << endl; 
      }
    | IDENTIFIER {
        cout << "Identifier detected: " << $1 << endl;
      }
    ;

/* Expression rule with error recovery */
expression:
    IDENTIFIER ASSIGN operand operator operand {
        if (isDeclared($1)) {
            SymbolInfo assignee = getFromSymbolTable($1);
            
            NodeType leftNodeType;
            if ($3->type == NODE_IDENTIFIER) {
                leftNodeType = convertDataTypeToNodeType(getFromSymbolTable($3->value).type);
            } else {
                leftNodeType = $3->type;
            }
            
            NodeType rightNodeType;
            if ($5->type == NODE_IDENTIFIER) {
                rightNodeType = convertDataTypeToNodeType(getFromSymbolTable($5->value).type);
            } else {
                rightNodeType = $5->type;
            }

            if (convertDataTypeToNodeType(assignee.type) == leftNodeType && leftNodeType == rightNodeType) {
                $$ = createAssignmentNode($1, createOperatorNode($4->value, $3, $5));
                root = (root == nullptr) ? $$ : createSequenceNode(root, $$);
            } else {
                std::cerr << "Error: Type mismatch in operation or assignment to " << $1 << " at line " << linenum << std::endl;
            }
        } else {
            std::cerr << "Error: Variable " << $1 << " is not declared at line " << linenum << "." << std::endl;
        }
    }
    | IDENTIFIER ASSIGN operand {
        if (isDeclared($1)) {
            SymbolInfo assignee = getFromSymbolTable($1);
            
            NodeType operandNodeType;
            if ($3->type == NODE_IDENTIFIER) {
                operandNodeType = convertDataTypeToNodeType(getFromSymbolTable($3->value).type);
            } else {
                operandNodeType = $3->type;
            }

            if (convertDataTypeToNodeType(assignee.type) == operandNodeType) {
                $$ = createAssignmentNode($1, $3);
                root = (root == nullptr) ? $$ : createSequenceNode(root, $$);
            } else {
                std::cerr << "Error: Type mismatch in assignment to " << $1 << " at line " << linenum << std::endl;
            }
        } else {
            std::cerr << "Error: Variable " << $1 << " is not declared at line " << linenum << "." << std::endl;
        }
    }
    | data_type IDENTIFIER ASSIGN operand operator operand {
        if (!isDeclared($2)) {
            addToSymbolTable($2, $1);  // Add identifier with its type
            
            NodeType leftNodeType;
            if ($4->type == NODE_IDENTIFIER) {
                leftNodeType = convertDataTypeToNodeType(getFromSymbolTable($4->value).type);
            } else {
                leftNodeType = $4->type;
            }
            
            NodeType rightNodeType;
            if ($6->type == NODE_IDENTIFIER) {
                rightNodeType = convertDataTypeToNodeType(getFromSymbolTable($6->value).type);
            } else {
                rightNodeType = $6->type;
            }

            if (convertDataTypeToNodeType($1) == leftNodeType && leftNodeType == rightNodeType) {
                $$ = createAssignmentNode($2, createOperatorNode($5->value, $4, $6));
                root = (root == nullptr) ? $$ : createSequenceNode(root, $$);
            } else {
                std::cerr << "Error: Type mismatch in operation or assignment to " << $2 << " at line " << linenum << std::endl;
            }
        } else {
            std::cerr << "Error: Variable " << $2 << " already declared at line " << linenum << "." << std::endl;
        }
    }
    | data_type IDENTIFIER ASSIGN operand {
        if (!isDeclared($2)) {
            addToSymbolTable($2, $1);  // Add identifier with its type
            
            NodeType operandNodeType;
            if ($4->type == NODE_IDENTIFIER) {
                operandNodeType = convertDataTypeToNodeType(getFromSymbolTable($4->value).type);
            } else {
                operandNodeType = $4->type;
            }

            if (convertDataTypeToNodeType($1) == operandNodeType) {
                $$ = createAssignmentNode($2, $4);
                root = (root == nullptr) ? $$ : createSequenceNode(root, $$);
            } else {
                std::cerr << "Error: Type mismatch in assignment to " << $2 << " at line " << linenum << std::endl;
            }
        } else {
            std::cerr << "Error: Variable " << $2 << " already declared at line " << linenum << "." << std::endl;
        }
    }
    // Error recovery for invalid right-hand side expressions
    | IDENTIFIER ASSIGN error {
        std::cerr << "Error: Invalid right-hand side in assignment at line " << linenum << ". Skipping to next statement." << std::endl;
        yyerrok; // Recover from the error and continue parsing
    }
    | data_type IDENTIFIER ASSIGN error {
        std::cerr << "Error: Invalid right-hand side in declaration assignment at line " << linenum << ". Skipping to next statement." << std::endl;
        yyerrok; // Recover from the error and continue parsing
    }
    ;

/* Operand rule */
operand:
      INTEGER {
          $$ = new ASTNode(NODE_NUMBER, std::to_string($1));
      }
    | FLOAT {
          $$ = new ASTNode(NODE_NUMBER, std::to_string($1));
      }
    | IDENTIFIER {
          $$ = new ASTNode(NODE_IDENTIFIER, $1);
      }
    | STRING {
          $$ = new ASTNode(NODE_STRING, $1);  // Assuming strings are treated like identifiers
      }
    ;

/* Number rule */
num:
      INTEGER
    | FLOAT
    ;

/* Define operators */
operator:
    PLUS {
        $$ = new ASTNode(NODE_OPERATOR, "+");
    }
  | MINUS {
        $$ = new ASTNode(NODE_OPERATOR, "-");
    }
  | MULTIPLY {
        $$ = new ASTNode(NODE_OPERATOR, "*");
    }
  | DIVIDE {
        $$ = new ASTNode(NODE_OPERATOR, "/");
    }
  ;

/* Define what a statement should look like */
stmt:
      if_stmt {
        cout << "If statement executed successfully" <<endl;
      }
    | if_stmt else_stmt {
        cout <<"If else statement evaluated successfully"<<endl;
      }
    | if_stmt elif else_stmt {
        cout <<"If elif, else statement evaluated successfully"<<endl;
      }
    | loop_stmt {
        cout << "Loop statement executed successfully" <<endl;
      }
    | flow_control
    | function {
        cout << "Function evaluated" << endl;
    }
    ;

/* Define what a function should look like */
function:
      SIRA return_type IDENTIFIER LPAREN params RPAREN function_definition
    ;

/* Define what parameters should look like */
params:
      data_type IDENTIFIER COMMA params
      | data_type IDENTIFIER
    ;

/* Define what a return type is */
return_type:
      NOVEM
      | DECEM
      | DUO
      | UNUM
      | VERBUM
      | MINEM
    ;

/* Define what a data type is */
data_type:
      NOVEM   { $$ = TYPE_INTEGER; }
    | DECEM   { $$ = TYPE_FLOAT; }
    | DUO     { $$ = TYPE_BOOLEAN; }
    | UNUM    { $$ = TYPE_BOOLEAN; }
    | VERBUM  { $$ = TYPE_STRING; }
    ;

/* Define what an if statement should look like */
if_stmt:
      KEHONE LPAREN conditions RPAREN definition
    ;

/* Define what an else statement should look like */
else_stmt:
      KALHONE definition
    ;

/* Define what an elif should look like */
elif:
      elif_stmt
    | elif_stmt elif
  ;

/* Define what an elif statement should look like */
elif_stmt:
      LELAKEHONE LPAREN conditions RPAREN definition
    ;

/* Define what a loop should look like */
loop_stmt:
      while_loop
    | for_loop
    ;

/* Define what a while loop should look like */
while_loop:
      ESKEHONE LPAREN conditions RPAREN definition
    ;

/* Define what a for loop should look like */
for_loop:
      DELTA LPAREN for_loop_declaration RPAREN definition
    ;

/* Define flow control */
flow_control:
      AQUM SEMICOLON
    | QETEL SEMICOLON
    ;

/* Define what a for loop declaration should look like */
for_loop_declaration:
      for_loop_initialization SEMICOLON conditions SEMICOLON increment_decrement_list
    ;

/* Define what a for loop initialization should look like */
for_loop_initialization:
      data_type IDENTIFIER ASSIGN num
    | data_type IDENTIFIER ASSIGN num COMMA for_loop_initialization
    ;

/* Define what an increment/decrement list should look like */
increment_decrement_list:
      increment_decrement
    | increment_decrement_list COMMA increment_decrement
    ;

/* Define what an increment/decrement should look like */
increment_decrement:
      IDENTIFIER PLUS PLUS
    | IDENTIFIER MINUS MINUS
    ; 

/* Define what a condition should look like */
conditions:
      condition_expression
    ;

/* Define what a condition expression should look like */
condition_expression:
      or_expression
    | LPAREN condition_expression RPAREN
    ;

/* Handle OR operations */
or_expression:
      or_expression OR and_expression
    | and_expression
    ;

/* Handle AND operations */
and_expression:
      and_expression AND not_expression
    | not_expression
    ;

/* Handle NOT operations */
not_expression:
      NOT not_expression
    | comparison
    ;

/* Handle comparisons */
comparison:
      operand comparison_operators operand
    | boolean
    | IDENTIFIER
    ;

/* Define what a definition should look like for a loop and an if statement */
definition:
      LBRACE body RBRACE
    ;

/* Define what a definition should look like for a function (because functions can have a return statement) */
function_definition:
      LBRACE body RBRACE
    | LBRACE body return_statement RBRACE
    ;

/* Define what a return statement should look like for a function */
return_statement:
      MELS IDENTIFIER SEMICOLON
    | MELS STRING SEMICOLON
    | MELS FLOAT SEMICOLON
    | MELS INTEGER SEMICOLON
    | MELS boolean SEMICOLON
    ;

/* Define what a boolean should look like */
boolean:
      EWNET
    | HASET
    ;

/* Define what a body should look like for if statements and loops */
body:
      statement body
    | /* empty */
    ;

/* Define comparison operators */
comparison_operators:
      EQ
    | NE
    | LT 
    | GT 
    | LE 
    | GE
    ;

%%

/* User Code Section */

/* Function for handling errors, called by Bison when a syntax error is encountered */
void yyerror(const char *s)
{
    cerr << "Error: " << s << " at line " << linenum << endl;
}

/* Helper functions */
ASTNodePtr createAssignmentNode(const std::string &identifier, ASTNodePtr right) {
    ASTNodePtr assignNode = new ASTNode(NODE_ASSIGNMENT, "=");
    assignNode->left = new ASTNode(NODE_IDENTIFIER, identifier);
    assignNode->right = right;
    return assignNode;
}

ASTNodePtr createOperatorNode(const std::string &op, ASTNodePtr left, ASTNodePtr right) {
    ASTNodePtr opNode = new ASTNode(NODE_OPERATOR, op);
    opNode->left = left;
    opNode->right = right;
    return opNode;
}

ASTNodePtr createSequenceNode(ASTNodePtr first, ASTNodePtr second) {
    ASTNodePtr sequenceNode = new ASTNode(NODE_SEQUENCE, ";");
    sequenceNode->left = first;
    sequenceNode->right = second;
    return sequenceNode;
}

void printAST(ASTNode* node, int indent = 0) {
    if (!node) return;

    for (int i = 0; i < indent; ++i) std::cout << "  ";
    std::cout << "Node Type: " << node->type << ", Value: " << node->value << std::endl;

    printAST(node->left, indent + 1);
    printAST(node->right, indent + 1);
}

NodeType convertDataTypeToNodeType(DataType dataType) {
    switch (dataType) {
        case TYPE_INTEGER:
            return NODE_NUMBER;
        case TYPE_FLOAT:
            return NODE_NUMBER; // Assuming both integers and floats are treated as numbers in AST
        case TYPE_STRING:
            return NODE_STRING;
        case TYPE_BOOLEAN:
            return NODE_BOOLEAN;
        default:
            return NODE_UNKNOWN; // You can define NODE_UNKNOWN in your `ASTNode.h` or handle this case appropriately
    }
}

/* Main function */
int main(int argc, char **argv)
{
    yydebug = 0;  // Enable debugging when it is 1
    // If a filename is provided as a command-line argument, open the file
    if (argc > 1)
    {
        FILE *file = fopen(argv[1], "r");
        if (!file)
        {
            // If the file cannot be opened, print an error message and exit
            cerr << "Could not open file: " << argv[1] << endl;
            return 1;
        }
        // Set yyin to the file pointer so Flex reads from the file
        yyin = file;
    }
    else
    {
        // If no file is provided, read from standard input (e.g., keyboard)
        yyin = stdin;
    }

    // Call yyparse to start parsing the input
    int result = yyparse();
    if(result == 0 && root!=nullptr) {
        std::cout << "AST Root Node Type: " << root->type << std::endl;
        printAST(root);
        generateTASMFile(root,"TestProgramShieldlang");
        std::cout << "File parsed and TASM generated successfully." << std::endl;
    } else {
        std::cerr << "Parsing failed or root is null." << std::endl;
    }

    return 0;
}
